package gitlet;


import java.io.File;
import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.TreeMap;
import java.util.Date;

import static gitlet.Utils.*;

/**
 * This class manages the commits.
 * The Field commits is a TreeMap of the commits.
 * Key: hash value of the commit; Value: the point to the Commit Instance.
 */
public class Commit {

    /** The file that saves the Serialised Field: Commits. */
    public static final File COMMITS_FILE = join(Repository.OBJ_DIR, "commits");

    /** The file that saves the Serialised Field: Short Commits. */
    public static final File SHORT_COMMITS_FILE = join(Repository.OBJ_DIR, "short_commits");

    /** The Hash code of the init commit */
    public static final String INIT_HASH = "000000000000000000000000000000";

    /** The Message of the init commit */
    public static final String INIT_MSG = "initial commit";

    /**
     * A TreeMap of Commits. Every Commit has a hash code.
     * The Map saves the hash codes and the points of the instance.
     * Key: hash value of the commit; Value: the point to the Commit Instance.
     */
    private TreeMap<String, Cmt> commits;

    /**
     * A TreeMap of Short Hash Codes.
     * Key: first 6 characters of the Hash Code; Value: Hash Code of the commits..
     */
    private TreeMap<String, String> shortCommits;

    /** Cmt is a support class which respects a commit. */
    protected static class Cmt implements Serializable {

        /** The message of this Commit. */
        private final String message;

        /** The timeStamp of this Commit. */
        private final long timeStamp;

        /** The hash of this Commit. */
        private final String hash;

        /** The File Tree of this Commit.
         * Key is the file name, Value is the Hash Code.
         */
        private final TreeMap<String, String> tree;

        /** The Hash Value of the parent commit of this Commit*/
        private final String[] parent;

        /** The constructor for only one parent. */
        public Cmt(String message, long timeStamp, String hash,
                   TreeMap<String, String> tree, String parent) {
            this.message = message;
            this.timeStamp = timeStamp;
            this.hash = hash;
            this.tree = tree;
            this.parent = new String[2];
            this.parent[0] = parent;
        }

        /** The constructor for the init commit. */
        private Cmt(String message, long timeStamp, String hash) {
            this.message = message;
            this.timeStamp = timeStamp;
            this.hash = hash;
            this.tree = new TreeMap<>();
            this.parent = new String[]{null, null};
        }
    }

    /** The Filed commits is generated by de-serialising from a disk file,
     * or generate a new one if not exist.
     */
    public Commit() {
        try {
            this.commits = (TreeMap<String, Cmt>)
                    readObject(COMMITS_FILE, TreeMap.class);
            this.shortCommits = (TreeMap<String, String>)
                    readObject(SHORT_COMMITS_FILE, TreeMap.class);
        } catch (IllegalArgumentException e) {
            this.commits = new TreeMap<>();
            this.shortCommits = new TreeMap<>();
            newInitCommit();
        }
    }

    /** Return the commit by Hash Code */
    public Cmt getCommit(String hashCode) {
        hashCode = getHashCode(hashCode);
        if (commits.containsKey(hashCode)) {
            return commits.get(hashCode);
        }
        return null;
    }

    /** Return the commit[] by message, may return null if it is empty. */
    public Cmt[] getCommit(boolean isMsg, String message) {

        ArrayList<Cmt> res = new ArrayList<>();
        for (String hashCode: commits.keySet()) {
            Cmt commit = getCommit(hashCode);
            if (commit.message.equals(message)) {
                res.add(commit);
            }
        }
        if (res.isEmpty()) {
            return null;
        }
        return res.toArray(new Cmt[0]);
    }

    /** Return all commits, may return null if it is empty.*/
    public Cmt[] getAllCommits() {
        return commits.values().toArray(new Cmt[0]);
    }

    /** Return if the commits has a commit with the hashCode. */
    public boolean hasCommit(String hashCode) {
        return commits.containsKey(getHashCode(hashCode));
    }

    /** Create a new commit and add to the Field commits.
     *  This method will automatically serialise the Field commits
     *  and save it to the disk.
     */
    public String newCommit(String msg, TreeMap<String, String> tree, String parent) {
        long ts = (new Date()).getTime();
        String hashCode = sha1(String.valueOf(tree.hashCode()), msg, parent, String.valueOf(ts));
        Cmt commit = new Cmt(msg, ts, hashCode, tree, parent);
        shortCommits.put(Commit.getShortHashCode(hashCode), hashCode);
        commits.put(hashCode, commit);
        saveCommits();
        return hashCode;
    }

    /** Create an empty init commit and add to the Field commits */
    public void newInitCommit() {
        Cmt commit = new Cmt(INIT_MSG, 0, INIT_HASH);
        shortCommits.put(Commit.getShortHashCode(INIT_HASH), INIT_HASH);
        commits.put(INIT_HASH, commit);
        saveCommits();
    }

    /** Serialise the Field commits and write to disk. */
    public void saveCommits() {
        writeObject(SHORT_COMMITS_FILE, shortCommits);
        writeObject(COMMITS_FILE, commits);
    }

    /** Return full hashCode */
    private String getHashCode(String hashCode) {
        if (hashCode.length() == 8) {
            return shortCommits.get(hashCode);
        }
        return hashCode;
    }

    /** Return short hashCode */
    private static String getShortHashCode(String hashCode) {
        if (hashCode.length() > 8) {
            return hashCode.substring(0, 8);
        }
        return hashCode;
    }

    //---------------------------------------------------------------//
    // The properties of a commit.

    /** Return the Hash Code of the 1ST parent commit. */
    public static String getParent(Cmt commit) {
        return commit.parent[0];
    }

    /** Return the Hash Code of the parents commit, may return null if it is the init commit. */
    public static String[] getParents(Cmt commit) {
        return commit.parent;
    }

    /** Return the Hash Code of the commit. */
    public static String getHash(Cmt commit) {
        return commit.hash;
    }

    /** Return the Hash Code of the file in the commit. */
    public static String getHashOfFile(Cmt commit, String fileName) {
        return commit.tree.get(fileName);
    }

    /** Return the Date Time of the commit. */
    public static String getDateTime(Cmt commit) {
        Date date = new Date(commit.timeStamp);
        String pattern = "E MMM F HH:mm:ss yyyy Z";
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);

        return simpleDateFormat.format(date);
    }

    /** Return the message of the commit. */
    public static String getMessage(Cmt commit) {
        return commit.message;
    }

    /** Return the file names that tracked in a commit, may return null if it is empty.*/
    public static String[] getFileNames(Cmt commit) {
        if (commit.tree == null) {
            return null;
        }
        return commit.tree.keySet().toArray(new String[0]);
    }

    /** Return whether the file names is tracked in a commit. */
    public static boolean commitHasFile(Cmt commit, String fileName) {
        return commit.tree.containsKey(fileName);
    }

    /** Add the second parent to a Commit */
    public static void addParent(Cmt commit, String givenPoint) {
        commit.parent[1] = givenPoint;
    }
}
